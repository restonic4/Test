import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.gradle.internal.os.OperatingSystem

import java.text.SimpleDateFormat

plugins {
    id 'java'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
}

group = "${group}"
version = "${version}"

// Determine the platform for native dependencies
def platform
if (OperatingSystem.current().isWindows()) {
    platform = "windows"
} else if (OperatingSystem.current().isLinux()) {
    platform = "linux"
} else if (OperatingSystem.current().isMacOsX()) {
    platform = "macos"
}

repositories {
    mavenCentral()
}

configurations {
    clientImplementation.extendsFrom implementation
    clientRuntimeOnly.extendsFrom runtimeOnly
    serverImplementation.extendsFrom implementation
    serverRuntimeOnly.extendsFrom runtimeOnly
}

dependencies {
    // LWJGL Core
    clientImplementation "org.lwjgl:lwjgl:${lwjglVersion}"
    clientImplementation "org.lwjgl:lwjgl-glfw:${lwjglVersion}"
    clientImplementation "org.lwjgl:lwjgl-opengl:${lwjglVersion}"
    clientImplementation "org.lwjgl:lwjgl-jemalloc:${lwjglVersion}"
    clientImplementation "org.lwjgl:lwjgl-stb:${lwjglVersion}"
    clientImplementation "org.lwjgl:lwjgl-openal:${lwjglVersion}"

    // LWJGL Native dependencies for the determined platform
    clientRuntimeOnly "org.lwjgl:lwjgl:${lwjglVersion}:natives-${platform}"
    clientRuntimeOnly "org.lwjgl:lwjgl-glfw:${lwjglVersion}:natives-${platform}"
    clientRuntimeOnly "org.lwjgl:lwjgl-opengl:${lwjglVersion}:natives-${platform}"
    clientRuntimeOnly "org.lwjgl:lwjgl-jemalloc:${lwjglVersion}:natives-${platform}"
    clientRuntimeOnly "org.lwjgl:lwjgl-stb:${lwjglVersion}:natives-${platform}"
    clientRuntimeOnly "org.lwjgl:lwjgl-openal:${lwjglVersion}:natives-${platform}"

    // Math
    implementation "org.joml:joml:${jomlVersion}"

    // Networking
    implementation "io.netty:netty-all:${nettyVersion}"

    // Logger
    implementation "org.apache.logging.log4j:log4j-api:${log4jVersion}"
    implementation "org.apache.logging.log4j:log4j-core:${log4jVersion}"
    annotationProcessor "org.apache.logging.log4j:log4j-core:${log4jVersion}"

    // Reflection
    implementation "org.reflections:reflections:${reflectionVersion}"
    shadow "org.reflections:reflections:${reflectionVersion}"
}



// -- BUILDS -- //

// Build client jar
tasks.register('clientShadowJar', ShadowJar) {
    archiveClassifier.set('client')
    from sourceSets.main.output // Include common code
    from sourceSets.client.output // Include client-specific code
    from sourceSets.server.output // Include server-specific code, this is for single-player
    configurations = [project.configurations.clientRuntimeClasspath, project.configurations.serverRuntimeClasspath] // Client-only deps + common deps + server deps for single-player

    manifest {
        attributes 'Main-Class': clientLauncherClass
    }
}

// Build server jar
tasks.register('serverShadowJar', ShadowJar) {
    archiveClassifier.set('server')
    from sourceSets.main.output // Include common code
    from sourceSets.server.output // Include server-specific code
    configurations = [project.configurations.serverRuntimeClasspath] // Server-only deps + common deps

    manifest {
        attributes 'Main-Class': serverLauncherClass
    }
}



// -- RUNS -- //

// Run client
tasks.register('runClient', JavaExec) {
    dependsOn clientShadowJar
    group = "Execution"
    description = "Runs the client application using the client shadow JAR"
    mainClass = clientLauncherClass
    classpath = files(tasks.clientShadowJar.outputs.files.singleFile)

    // -- Command Line Arguments -- //
    def gameDirArg = project.projectDir.absolutePath + '/' + project.findProperty('clientRunDir')
    args(
            '--gamedir', gameDirArg,
            '--username', project.findProperty('runUsername'),
            '--uuid', project.findProperty('runUUID')
    )

    // -- Run dir -- //
    systemProperty "logLevel", System.getProperty("logLevel", "DEBUG")

    def gameDirFile = project.file(gameDirArg)

    doFirst {
        if (!gameDirFile.exists()) {
            logger.warn("Working directory/Game directory does not exist, creating: ${gameDirFile.absolutePath}")
            gameDirFile.mkdirs()
        } else if (!gameDirFile.isDirectory()) {
            throw new InvalidUserDataException("Specified game directory exists but is not a directory: ${gameDirFile.absolutePath}")
        }
    }

    workingDir gameDirFile
}

// Run server
tasks.register('runServer', JavaExec) {
    dependsOn serverShadowJar
    group = "Execution"
    description = "Runs the server application using the server shadow JAR"
    mainClass = serverLauncherClass
    classpath = files(tasks.serverShadowJar.outputs.files.singleFile)

    // -- Command Line Arguments -- //
    def gameDirArg = project.projectDir.absolutePath + '/' + project.findProperty('serverRunDir')
    args '--gamedir', gameDirArg

    // -- Run dir -- //
    systemProperty "logLevel", System.getProperty("logLevel", "DEBUG")

    def gameDirFile = project.file(gameDirArg)

    doFirst {
        if (!gameDirFile.exists()) {
            logger.warn("Working directory/Game directory does not exist, creating: ${gameDirFile.absolutePath}")
            gameDirFile.mkdirs()
        } else if (!gameDirFile.isDirectory()) {
            throw new InvalidUserDataException("Specified game directory exists but is not a directory: ${gameDirFile.absolutePath}")
        }
    }

    workingDir gameDirFile
}



// -- JAR CONFIG FOR BUILDS -- //

java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

shadowJar {
    archiveBaseName.set("${project.name}")
    archiveVersion.set("${project.version}")

    archiveClassifier.set('')
}

sourceSets {
    main {
        java {
            srcDirs = ['src/main/java'] // Shared code
        }
        resources {
            srcDirs = ['src/main/resources']
        }
    }
    server {
        java {
            srcDirs = ['src/server/java']
            compileClasspath += sourceSets.main.output
            runtimeClasspath += sourceSets.main.output
        }
        resources {
            srcDirs = ['src/server/resources']
        }
    }
    client {
        java {
            srcDirs = ['src/client/java']
            compileClasspath += sourceSets.main.output
            runtimeClasspath += sourceSets.main.output

            // We include the server side to be able to run single-player
            compileClasspath += sourceSets.server.output
            runtimeClasspath += sourceSets.server.output
        }
        resources {
            srcDirs = ['src/client/resources', 'src/server/resources']
        }
    }
}

// Test

tasks.register('generateProjectTree', DefaultTask) {
    group = "Documentation"
    description = "Generates a file tree listing for main, client, and server source sets into project-tree.txt"

    def outputFile = project.file('project-tree.txt')
    outputs.file(outputFile)

    doLast {
        logger.lifecycle("Generating project tree structure...")
        def outputContent = new StringBuilder()
        def dirsToScan = [ 'src/main', 'src/client', 'src/server' ]

        def command // Variable to hold the command executable path or name
        def argsPrefix = [] // Arguments like /F

        // Determine command and arguments based on OS
        if (OperatingSystem.current().isWindows()) {
            // --- CHANGE: Use the full path to tree.com on Windows ---
            command = 'C:/Windows/System32/tree.com' // Use forward slashes, Groovy/Gradle handles it
            argsPrefix.add("/F") // Include filenames
            // Optional: Use ASCII lines if default box drawing chars cause issues
            // argsPrefix.add("/A")
        } else {
            // Assume 'tree' is in PATH for Linux/macOS
            command = "tree"
        }

        outputContent.append("Project File Tree (${new Date().format('yyyy-MM-dd HH:mm:ss')})\n")
        outputContent.append("=====================================================\n\n")

        dirsToScan.each { dirPath ->
            def targetDir = project.file(dirPath)

            if (targetDir.exists() && targetDir.isDirectory()) {
                outputContent.append("Tree for: ${targetDir.absolutePath}\n")
                outputContent.append("----------------------------------------\n")

                // --- Arguments for exec ---
                // Windows tree.com syntax is typically: tree [drive:][path] [/F] [/A]
                // Gradle's exec usually takes args as a list: [arg1, arg2, ...]
                // We will pass the path as an argument along with /F.
                def currentArgs = []
                currentArgs.addAll(argsPrefix) // Add /F (and potentially /A)
                currentArgs.add(targetDir.absolutePath) // Add the target directory path

                def stdout = new ByteArrayOutputStream()
                def stderr = new ByteArrayOutputStream()

                try {
                    logger.info("Executing: {} {}", command, currentArgs.join(' ')) // Log the command being run
                    def result = project.exec {
                        executable = command // Use the full path on Windows now
                        args = currentArgs
                        standardOutput = stdout
                        errorOutput = stderr
                        ignoreExitValue = true
                    }

                    if (result.exitValue == 0) {
                        // Attempt to decode using default charset, fallback to ISO-8859-1 for console output
                        try {
                            outputContent.append(stdout.toString(java.nio.charset.Charset.defaultCharset().name()).trim())
                        } catch (Exception e) {
                            logger.warn("Failed to decode tree output using default charset, trying ISO-8859-1")
                            outputContent.append(stdout.toString("ISO-8859-1").trim())
                        }
                    } else {
                        // Provide a more specific error if using the full path
                        def errorMsg = "ERROR: Command '${command}' failed for '${dirPath}' (Exit code: ${result.exitValue}).\nStderr:\n${stderr.toString().trim()}"
                        outputContent.append(errorMsg)
                        logger.warn(errorMsg)
                    }
                } catch (Exception e) {
                    // Update error message to reflect using the full path potentially
                    def errorMsg = "ERROR: Could not execute command '${command}'. Ensure it exists at that path and you have permissions.\nException for dir '${dirPath}': ${e.message}"
                    outputContent.append(errorMsg)
                    logger.error(errorMsg, e)
                }

                outputContent.append("\n\n")

            } else {
                def warnMsg = "Directory not found or is not a directory, skipping: ${targetDir.absolutePath}"
                outputContent.append(warnMsg + "\n\n")
                logger.warn(warnMsg)
            }
        }

        // Write the final accumulated content to the output file
        outputFile.write(outputContent.toString())
        logger.lifecycle("Project tree generated successfully: ${outputFile.absolutePath}")
    }
}

// Gource

// Define a map to hold configurations for each mode
def modeConfig = [
        'last24Hours': [dateShift: [Calendar.DATE, -1], secondsPerDay: 20],
        'lastWeek': [dateShift: [Calendar.WEEK_OF_YEAR, -1], secondsPerDay: 8],
        'lastMonth': [dateShift: [Calendar.MONTH, -1], secondsPerDay: 4],
        'lastYear': [dateShift: [Calendar.YEAR, -1], secondsPerDay: 1],
        'all': [dateShift: null, secondsPerDay: 1],
        'allSlow': [dateShift: null, secondsPerDay: 4]
]

// Utility function to get formatted date string
static def getFormattedDateString(Date date) {
    def dateFormat = new SimpleDateFormat("\"yyyy-MM-dd HH:mm:ss Z\"")
    dateFormat.setTimeZone(TimeZone.getDefault())
    return dateFormat.format(date)
}

// Function to get date based on mode
static def getStartDate(mode, modeConfig) {
    def config = modeConfig[mode]
    if (config == null) {
        throw new GradleException("Invalid time mode: $mode")
    }
    if (config.dateShift == null) {
        return null
    }
    Calendar calendar = Calendar.getInstance()
    calendar.add(config.dateShift[0], config.dateShift[1])
    return getFormattedDateString(calendar.getTime())
}

// Function to get seconds per day based on mode
static def getSecondsPerDay(mode, modeConfig) {
    def config = modeConfig[mode]
    if (config == null) {
        throw new GradleException("Invalid time mode: $mode")
    }
    return config.secondsPerDay
}


tasks.register('gource', Exec) {
    // Set the desired mode
    def mode = "${gourceMode}"
    def startDate = getStartDate(mode, modeConfig)
    def secondsPerDay = getSecondsPerDay(mode, modeConfig)

    // Build the list of arguments
    def args = [
            'gource',
            '-f', '-1920x1080',
            '--seconds-per-day', "${secondsPerDay}",
            '--title', "${appName}",
            '--hide', 'mouse,progress',
            '--highlight-colour', 'FFD700',
            '--highlight-user', 'restonic4',
            '--highlight-user', 'Dinax',
            '--caption-file', 'gource/captions.txt',
            '--font-scale', '2'
    ]

    // Add the start date argument if it's not null
    if (startDate != null) {
        args += ['--start-date', startDate]
    }

    // Configure the command line
    commandLine 'cmd', '/c', args.join(' ')
}
